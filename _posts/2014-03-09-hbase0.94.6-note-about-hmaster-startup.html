<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>2014-03-09-hbase0.94.6-note-about-hmaster-startup</title></head><body><hr />
<p>layout: post</p>
<p>title: HBase0.94.6源码：HMaster启动过程</p>
<p>description: 记录HBase0.94.6 中HMaster启动过程</p>
<p>keywords: HBase0.94.6源码：HMaster启动过程</p>
<p>category: hadoop</p>
<p>tags: [hbase]</p>
<p>published: true</p>
<hr />
<p>版本：HBase 0.94.6-cdh4.3.0</p>
<h1 id="调试hmaster">调试HMaster</h1>
<blockquote>
<p><strong>说明：</strong></p>
<p>这部分参考和使用了<a href="https://github.com/codefollower/HBase-Research">https://github.com/codefollower/HBase-Research</a>上的代码，包括该作者自己写的一些<a href="https://github.com/codefollower/HBase-Research/tree/0.94/src/test/java/my/test">测试类</a>和<a href="https://github.com/codefollower/HBase-Research/blob/0.94/my-docs">文档</a>。</p>
</blockquote>
<p>首先，在IDE里启动HMaster和HRegionServer：</p>
<p>运行<code>/hbase/src/test/java/my/test/start/HMasterStarter.java</code>，当看到提示<code>Waiting for region servers count to settle</code>时，
再打开同目录中的HRegionServerStarter，统一运行该类。</p>
<p>此时会有两个Console，在HMasterStarter这个Console最后出现<code>Master has completed initialization</code>，这样的信息时就表示它启动成功了，而HRegionServerStarter这个Console最后出现<code>Done with post open deploy task</code>这样的信息时说明它启动成功了。</p>
<h1 id="main方法">main方法</h1>
<p>运行HMasterStarter类启动HMaster：</p>
<pre><code class="java">package my.test.start;

import java.io.File;

import my.test.TestBase;

import org.apache.hadoop.hbase.HConstants;
import org.apache.hadoop.hbase.master.HMaster;
import org.apache.hadoop.hbase.zookeeper.MiniZooKeeperCluster;

public class HMasterStarter {
    public static void deleteRecursive(File[] files) {
        if (files == null)
            return;
        for (File f : files) {
            if (f.isDirectory()) {
                deleteRecursive(f.listFiles());
            }
            f.delete();
        }
    }

    public static void main(String[] args) throws Exception {
        File f = TestBase.getTestDir();
        //删除临时测试目录
        deleteRecursive(f.listFiles());

        new ZookeeperThread().start();
        Thread.sleep(1000);
        HMaster.main(new String[] { &quot;start&quot; });
    }

    public static class ZookeeperThread extends Thread {
        public void run() {
            MiniZooKeeperCluster zooKeeperCluster = new MiniZooKeeperCluster();

            File zkDataPath = new File(TestBase.sharedConf.get(HConstants.ZOOKEEPER_DATA_DIR));
            int zkClientPort = TestBase.sharedConf.getInt(HConstants.ZOOKEEPER_CLIENT_PORT, 2181);
            zooKeeperCluster.setDefaultClientPort(zkClientPort);
            try {
                zooKeeperCluster.startup(zkDataPath);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>

<p>HMaster的入口是main方法，main方法需要传递一个参数，start或者stop。</p>
<p>main方法内首先打印hbase版本信息，然后在调用HMasterCommandLine的doMain方法。HMasterCommandLine继承自ServerCommandLine类并且ServerCommandLine类实现了Tool接口。</p>
<pre><code class="java">public void doMain(String args[]) throws Exception {
    int ret = ToolRunner.run(
      HBaseConfiguration.create(), this, args);
    if (ret != 0) {
      System.exit(ret);
    }
  }
</code></pre>

<p>doMain方法内会调用ToolRunner的run方法，查看ToolRunner类可以知道，实际上最后会调用HMasterCommandLine的run方法。</p>
<p>接下来会解析参数，根据参数值判断是执行startMaster方法还是stopMaster方法。</p>
<p>startMaster方法中分两种情况：本地模式和分布式模式。如果是分布式模式，通过反射调用HMaster的<strong>构造方法</strong>，并调用其start和join方法。</p>
<p>HMaster继承自HasThread类，而HasThread类实现了Runnable接口，故HMaster也是一个线程。</p>
<h1 id="hmaster的构造方法">HMaster的构造方法</h1>
<p>1、构造方法总体过程</p>
<p>创建Configuration并设置和获取一些参数。包括：</p>
<ul>
<li>在master上关掉block cache</li>
<li>设置服务端重试次数</li>
<li>获取主机名称和master端口号，默认为60000</li>
<li><strong>创建rpcServer</strong></li>
<li>zk授权登录和hbase授权</li>
<li>设置当前线程名称</li>
<li>判断是否开启复制：<code>Replication.decorateMasterConfiguration(this.conf);</code></li>
<li>设置<code>mapred.task.id</code></li>
<li><strong>创建ZooKeeperWatcher监听器</strong></li>
<li>启动rpcServer中的线程</li>
<li>创建一个MasterMetrics</li>
<li>判断是否进行健康检测：HealthCheckChore</li>
</ul>
<p>涉及到的参数有：</p>
<pre><code>hfile.block.cache.size
hbase.master.dns.interface
hbase.master.dns.nameserver
hbase.master.port
hbase.master.ipc.address
hbase.master.handler.count
hbase.regionserver.handler.count
hbase.master.buffer.for.rs.fatals
hbase.zookeeper.client.keytab.file
hbase.zookeeper.client.kerberos.principal
hbase.master.keytab.file
hbase.master.kerberos.principal
hbase.master.logcleaner.plugins
mapred.task.id
hbase.node.health.script.frequency
</code></pre>

<p>2、创建rpcServer并启动其中的线程：</p>
<p>通过反射创建RpcEngine的实现类，实现类可以在配置文件中配置（<code>hbase.rpc.engine</code>），默认实现为WritableRpcEngine。
调用getServer方法，其实也就是new一个HBaseServer类。</p>
<p>构造方法中：</p>
<ul>
<li>启动一个Listener线程，功能是监听client的请求，将请求放入nio请求队列，逻辑如下：</li>
<li>--&gt;创建n个selector，和一个n个线程的readpool，n由"ipc.server.read.threadpool.size"决定，默认为10</li>
<li>--&gt;读取每个请求的头和内容，将内容放入priorityQueue中</li>
<li>启动一个Responder线程，功能是将响应队列里的数据写给各个client的connection通道，逻辑如下：</li>
<li>--&gt;创建nio selector</li>
<li>--&gt;默认超时时间为15 mins</li>
<li>--&gt;依次将responseQueue中的内容写回各通道，并关闭连接，buffer=8k(代码写死)</li>
<li>--&gt;如果该请求的返回没有写完，则放回队列头，推迟再发送</li>
<li>--&gt;对于超时未完成的响应，丢弃并关闭相应连接</li>
<li>启动N(n默认为10)个Handler线程,功能是处理请求队列，并将结果写到响应队列</li>
<li>--&gt;读取priorityQueue中的call，调用对应的call方法获得value，写回out并调用doRespond方法，处理该请求，并唤醒writable　selector</li>
<li>--&gt;启动M(m默认为0)个Handler线程以处理priority</li>
</ul>
<p>3、创建ZooKeeperWatcher</p>
<p>构造函数中生成如下持久节点：</p>
<pre><code>/hbase
/hbase/root-region-server
/hbase/rs
/table/draining
/hbase/master
/hbase/backup-masters
/hbase/shutdown
/hbase/unassigned
/hbase/table94
/hbase/table
/hbase/hbaseid
/hbase/splitlog
</code></pre>

<h1 id="run方法">run方法</h1>
<p>1、总体过程</p>
<ul>
<li>创建MonitoredTask</li>
<li>调用becomeActiveMaster方法，block直至成为active master</li>
<li>当成为了master之后调用finishInitialization</li>
<li>loop循环等待，一直到stop发生</li>
</ul>
<p>2、becomeActiveMaster方法：</p>
<ul>
<li>创建ActiveMasterManager</li>
<li>ZooKeeperWatcher注册activeMasterManager监听器</li>
<li>stallIfBackupMaster：
    --&gt;先检查配置项"hbase.master.backup"，自己是否backup机器，如果是则直接block直至检查到系统中的active master挂掉(默认每3分钟检查一次) </li>
<li>创建clusterStatusTracker并启动</li>
<li>调用activeMasterManager的blockUntilBecomingActiveMaster方法。
    创建短暂的/hbase/master，此节点值为version+ServerName，如果创建成功，则删除备份节点；否则，创建备份节点
    获得/hbase/master节点上的数据，如果不为null，则获得ServerName，并判断是否是在当前节点上创建了/hbase/master，如果是则删除该节点，这是因为该节点已经是备份节点了。</li>
</ul>
<p>3、finishInitialization方法：</p>
<ul>
<li>创建MasterFileSystem对象，封装了master常用的一些文件系统操作，包括splitlog file、删除region目录、删除table目录、删除cf目录、检查文件系统状态等.</li>
<li>创建FSTableDescriptors对象</li>
<li>设置集群id</li>
<li>如果不是备份master，创建ExecutorService，维护一个ExecutorMap,一种Event对应一个Executor(线程池).可以提交EventHandler来执行异步事件；创建serverManager，管理regionserver信息,维护着onlineregion server 和deadregion server列表，处理regionserver的startups、shutdowns、 deaths，同时也维护着每个regionserver rpc stub.</li>
<li>调用initializeZKBasedSystemTrackers，初始化zk文件系统<ul>
<li>创建CatalogTracker, 它包含RootRegionTracker和MetaNodeTracker，对应/hbase/root-region-server和/hbase/unassigned/1028785192这两个结点(1028785192是.META.的分区名)。如果之前从未启动过hbase，那么在start CatalogTracker时这两个结点不存在。/hbase/root-region-server是一个持久结点，在RootLocationEditor中建立</li>
<li>创建 LoadBalancer，负责region在regionserver之间的移动，关于balancer的策略，可以通过hbase.regions.slop来设置load区间</li>
<li>创建 AssignmentManager，负责管理和分配region，同时它也会接受zk上关于region的event，根据event来完成region的上下线、关闭打开等工作。</li>
<li>创建 RegionServerTracker: 监控"/hbase/rs"结点，通过ZK的Event来跟踪onlineregion servers， 如果有rs下线，删除ServerManager中对应的onlineregions.</li>
<li>创建 DrainingServerTracker: 监控"/hbase/draining"结点</li>
<li>创建 ClusterStatusTracker，监控"/hbase/shutdown"结点维护集群状态</li>
<li>创建SnapshotManager</li>
</ul>
</li>
<li>如果不是备份master，初始化MasterCoprocessorHost并执行startServiceThreads()<ul>
<li>创建一些executorService</li>
<li>创建logCleaner并启动</li>
<li>创建hfileCleaner并启动</li>
<li>创建jetty的infoServer并启动，默认端口为60010</li>
<li>启动healthCheckChore</li>
<li>打开rpcServer</li>
</ul>
</li>
<li>等待RegionServer注册。满足以下这些条件后返回当前所有region server上的region数后继续： <ul>
<li>a 至少等待4.5s("hbase.master.wait.on.regionservers.timeout") </li>
<li>b 成功启动regionserver节点数&gt;=1("hbase.master.wait.on.regionservers.mintostart") </li>
<li>c 1.5s内没有regionsever死掉或新启动("hbase.master.wait.on.regionservers.interval") </li>
</ul>
</li>
<li>如果不是备份master，启动assignmentManager</li>
<li>然后splitLogAfterStartup，从hlog中恢复数据，这是一个很长的逻辑： <ul>
<li>--&gt;依次检查每一个hlog目录，查看它所属的region server是否online，如果是则不需要做任何动作，region server自己会恢复数据，如果不是，则需要将它分配给其它的region server </li>
<li>--&gt;split是加锁操作: </li>
<li>--&gt; 创建一个新的hlogsplitter,遍历每一个server目录下的所有hlog文件，依次做如下操作。（如果遇到文件损坏等无法跳过的错误，配 置"hbase.hlog.split.skip.errors=true"以忽略之） </li>
<li>--&gt;启动"hbase.regionserver.hlog.splitlog.writer.threads"(默认为3)个线程，共使用128MB内存，启动这些写线程 </li>
<li>--&gt;先通过lease机制检查文件是否能够append，如果不能则死循环等待 </li>
<li>--&gt;把hlog中的内容全部加载到内存中(内存同时被几个写线程消费) </li>
<li>--&gt;把有损坏并且跳过的文件移到/hbase/.corrupt/目录中 </li>
<li>--&gt; 把其余己经处理过的文件移到/hbase/.oldlogs中，然后删除原有的server目录 </li>
<li>--&gt; 等待写线程结束，返回新写的所有路径 </li>
<li>--&gt;解锁</li>
<li>写线程逻辑： </li>
<li>--&gt;从内存中读出每一行数据的key和value，然后查询相应的region路径。如果该region路径不存在，说明该region很可能己经被split了，则不处理这部分数据,因为此时忽略它们是安全的。 </li>
<li>--&gt;如果上一步能查到相应的路径，则到对应路径下创建"recovered.edits"文件夹(如果该文件夹存在则删除后覆盖之)，然后将数据写入该文件夹  </li>
</ul>
</li>
<li>开始分配root和meta表：assignRootAndMeta</li>
<li>enableServerShutdownHandler</li>
<li>assignmentManager.joinCluster();</li>
<li>fixupDaughters(status)</li>
<li>如果不是备份master</li>
<li>启动balancerChore线程，运行LoadBalancer</li>
<li>启动startCatalogJanitorChore，周期性扫描.META.表上未使用的region并回收</li>
<li>registerMBean</li>
<li>serverManager.clearDeadServersWithSameHostNameAndPortOfOnlineServer</li>
<li>如果不是备份master，cpHost.postStartMaster</li>
</ul>
<h1 id="masterfilesystem构造方法">MasterFileSystem构造方法</h1>
<p>在<code>HMaster.finishInitialization</code>方法中触发了MasterFileSystem的构造方法，该类在HMaster类中会被以下类使用：</p>
<ul>
<li>LogCleaner</li>
<li>HFileCleaner</li>
</ul>
<p>另外该类可以完成拆分log的工作：</p>
<pre><code class="java">  /**
   * Override to change master's splitLogAfterStartup. Used testing
   * @param mfs
   */
  protected void splitLogAfterStartup(final MasterFileSystem mfs) {
    mfs.splitLogAfterStartup();
  }
</code></pre>

<p>这里主要是关心创建了哪些目录，其他用途暂不分析。</p>
<p>1、接下来，看其构造方法运行过程：</p>
<ul>
<li>获取rootdir：由参数<code>hbase.rootdir</code>配置</li>
<li>获取tempdir：<code>${hbase.rootdir}/.tmp</code></li>
<li>获取文件系统的uri，并设置到<code>fs.default.name</code>和<code>fs.defaultFS</code></li>
<li>判断是否进行分布式文件拆分，参数：<code>hbase.master.distributed.log.splitting</code>，如果需要，则创建SplitLogManager</li>
<li>创建oldLogDir，调用createInitialFileSystemLayout方法</li>
<li>checkRootDir<ul>
<li>等待fs退出安全模式(默认10秒钟轮循一次，可通过参数<code>hbase.server.thread.wakefrequency</code>调整</li>
<li>如果hbase.rootdir目录不存在则创建它，然后在此目录中创建名为"hbase.version"的文件，内容是文件系统版本号，当前为7；如果hbase.rootdir目录已存在，则读出"hbase.version"文件的内容与当前的版本号相比，如果不相等，则打印错误信息(提示版本不对)，抛出异常FileSystemVersionException</li>
<li>检查hbase.rootdir目录下是否有名为"hbase.id"的文件，如果没有则创建它，内容是随机生成的UUID(总长度36位，由5部份组成，用"-"分隔)，如: 6c43f934-37a2-4cae-9d49-3f5abfdc113d</li>
<li>读出"hbase.id"的文件的内容存到clusterId字段</li>
<li>判断hbase.rootdir目录中是否有"-ROOT-/70236052"目录，没有的话说明是第一次启动hbase，进入<strong>bootstrap</strong>方法</li>
<li>createRootTableInfo 建立"-ROOT-"表的描述文件，判断<code>hbase.rootdir/-ROOT-</code>目录中是否存在.tableinfo开头的文件，另外还创建了.tmp目录</li>
</ul>
</li>
<li>checkTempDir</li>
<li>如果oldLogDir（<code>${hbase.rootdir}/.oldlogs</code>）不存在，则创建</li>
</ul>
<p>2、bootstrap方法运行过程：</p>
<ul>
<li>调用HRegion.createHRegion建立"-ROOT-"分区和".META."分区</li>
<li>把".META."分区信息加到"-ROOT-"表，并关闭分区和hlog</li>
</ul>
<h1 id="总结">总结</h1>
<p>经过上面分析之后，来看看zookeeper创建的一些目录分布式由哪个类来监控的：</p>
<ul>
<li><code>/hbase</code></li>
<li><code>/hbase/root-region-server</code>：RootRegionTracker，监控root所在的regionserver</li>
<li><code>/hbase/rs</code>：RegionServerTracker，监控regionserver的上线和下线</li>
<li><code>/table/draining</code>：DrainingServerTracker，监听regionserver列表的变化</li>
<li><code>/hbase/master</code>：在HMaster中建立，并且是一个短暂结点，结点的值是HMaster的ServerName：<code>hostname,port,当前毫秒</code></li>
<li><code>/hbase/backup-masters</code></li>
<li><code>/hbase/shutdown</code>：ClusterStatusTracker，当HMaster启动之后，会讲当前时间（<code>Bytes.toBytes(new java.util.Date().toString())</code>）存到该节点</li>
<li><code>/hbase/unassigned</code>：MetaNodeTracker</li>
<li><code>/hbase/table94</code></li>
<li><code>/hbase/table</code></li>
<li><code>/hbase/hbaseid</code>：在HMaster.finishInitialization方法中调用ClusterId.setClusterId建立，结点值是UUID</li>
<li><code>/hbase/splitlog</code></li>
</ul>
<p>在HMaster启动之后，<code>${hbase.rootdir}</code>目录如下:</p>
<pre><code>.
├── -ROOT-   
│   ├── ..tableinfo.0000000001.crc
│   ├── .tableinfo.0000000001
│   ├── .tmp
│   └── 70236052
│       ├── ..regioninfo.crc
│       ├── .oldlogs
│       │   ├── .hlog.1402551641526.crc
│       │   └── hlog.1402551641526
│       ├── .regioninfo
│       ├── .tmp
│       └── info
│           ├── .5037e69a0c244bd78945aaa333d0230a.crc
│           └── 5037e69a0c244bd78945aaa333d0230a
├── .META.
│   └── 1028785192
│       ├── ..regioninfo.crc
│       ├── .oldlogs
│       │   ├── .hlog.1402551641701.crc
│       │   └── hlog.1402551641701
│       ├── .regioninfo
│       └── info
├── .hbase.id.crc
├── .hbase.version.crc
├── .oldlogs
├── .tmp
├── hbase.id
└── hbase.version
</code></pre>

<p>简单总结一下HMaster启动过程做了哪些事情：</p>
<ul>
<li>创建rpcServer，及HBaseServer</li>
<li>创建ZooKeeperWatcher监听器</li>
<li>阻塞等待成为activeMaster</li>
<li>创建master的一些文件目录</li>
<li>初始化一些基于zk的跟踪器</li>
<li>创建LoadBalancer</li>
<li>创建SnapshotManager</li>
<li>如果不是备份master<ul>
<li>创建logCleaner并启动</li>
<li>创建hfileCleaner并启动</li>
<li>创建jetty的infoServer并启动</li>
<li>启动健康检查</li>
<li>打开rpcServer</li>
</ul>
</li>
<li>等待RegionServer注册</li>
<li>从hlog中恢复数据</li>
<li>分配root和meta表</li>
<li>分配region</li>
<li>运行负载均衡线程</li>
<li>周期性扫描.META.表上未使用的region并回收</li>
</ul></body></html>