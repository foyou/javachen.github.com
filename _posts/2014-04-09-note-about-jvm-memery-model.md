---
layout: post

title: Java笔记：Java内容模型

description: 关于Java内容模型和垃圾回收的过程

keywords: Java内容模型

category: java

tags: [java,jvm]

published: true

---
# 基本概念

《深入理解Java内容模型》详细讲解了java的内存模型，这里对其中的一些基本概念做个简单的笔记。以下内容摘自 [《深入理解Java内存模型》读书总结](http://www.cnblogs.com/skywang12345/p/3447546.html)

## 1. 并发

定义：即，并发(同时)发生。在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。

并发需要处理两个关键问题：线程之间如何通信及线程之间如何同步。

- 通信 —— 是指线程之间如何交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
- 同步—— 是指程序用于控制不同线程之间操作发生相对顺序的机制。在Java中，可以通过volatile，synchronized, 锁等方式实现同步。


## 2. 主内存和本地内存

主内存 —— 即main memory。在java中，实例域、静态域和数组元素是线程之间共享的数据，它们存储在主内存中。

本地内存 —— 即local memory。 局部变量，方法定义参数 和 异常处理器参数是不会在线程之间共享的，它们存储在线程的本地内存中。


## 3. 重排序

定义：重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序。

说明：重排序分为——“编译器”和“处理器”两个方面，而“处理器”重排序又包括“指令级重排序”和“内存的重排序”。

关于重排序，我们需要理解它的思想：为了提高程序的并发度，从而提高性能！但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果！因此，就需要我们通过“volatile，synchronize，锁等方式”作出正确的实现同步。

## 4.内存屏障

定义：包括LoadLoad, LoadStore, StoreLoad, StoreStore共4种内存屏障。内存屏障是与相应的内存重排序相对应的。

作用：通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。

## 5. happens-before

定义：JDK5(JSR-133)提供的概念，用于描述多线程操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

作用：描述多线程操作之间的内存可见性。

## 6. 数据依赖性

定义：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

作用：编译器和处理器不会对“存在数据依赖关系的两个操作”执行重排序。


## 7. as-if-serial

定义：不管怎么重排序，程序的执行结果不能被改变。

## 8. 顺序一致性内存模型

定义：它是理想化的内存模型。有以下规则：

- 一个线程中的所有操作必须按照程序的顺序来执行。
- 所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

## 9. JMM

定义：Java Memory Mode，即Java内存模型。它是Java线程之间通信的控制机制。

说明：JMM对Java程序作出保证——如果程序是正确同步的，程序的执行将具有顺序一致性。即，程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。

## 10. 可见性

可见性一般用于指不同线程之间的数据是否可见。

在java中， 实例域、静态域和数组元素这些数据是线程之间共享的数据，它们存储在主内存中；主内存中的所有数据对该内存中的线程都是可见的。而局部变量，方法定义参数 和 异常处理器参数这些数据是不会在线程之间共享的，它们存储在线程的本地内存中；它们对其它线程是不可见的。

此外，对于主内存中的数据，在本地内存中会对应的创建该数据的副本(相当于缓冲)；这些副本对于其它线程也是不可见的。

## 11. 原子性

是指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。

# JVM内存区域

Jvm的内存模型分为Java虚拟机规范规定的概念模型以及具体厂商的实现模型。不同的厂商的Jvm在实现方式上可能会存在差别，本文中如果没有特别指出，Jvm 默认都指HotSpot Jvm。

下面部分内容摘自 [深入Java虚拟机](http://item.jd.com/11252778.html)第二章节Java内存区域与内存溢出异常。

下图是Java虚拟机所管理的几个运行时数据区域图：

![Java-Memory.png](/assets/images/2014/Java-Memory.png)

1）线程隔离数据区

所谓线程隔离数据区是指在多线程环境下，每个线程所独享的数据区域。主要有程序计数器、Java虚拟机栈、本地方法栈三个数据区。

a）程序计数器

[程序计数器](http://baike.baidu.com/view/178145.htm?fr=aladdin) —- 计算机处理器中的寄存器，它包含当前正在执行的指令的地址（位置）。当每个指令被获取，程序计数器的存储地址加一。在每个指令被获取之后，程序计数器指向顺序中的下一个指令。当计算机重启或复位时，程序计数器通常恢复到零。

在Java中程序计数器是一块较小的内存空间，充当当前线程所执行的字节码的行号指示器的角色。

在多线程环境下，当某个线程失去处理器执行权时，需要记录该线程被切换出去时所执行的程序位置。从而方便该线程被切换回来(重新被处理器处理)时能恢复到当初的执行位置，因此每个线程都需要有一个独立的程序计数器。各个线程的程序计数器互不影响，并且独立存储。

  - 当线程正在执行一个java方法时，这个程序计数器记录的时正在执行的虚拟机字节码指令的地址。
  - 当线程执行的是[Native方法](http://www.enet.com.cn/article/2007/1029/A20071029886398.shtml)，这个计数器值为空。
  - 此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

b）Java虚拟机栈

Java虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个[栈帧](http://baike.baidu.com/view/8128123.htm?fr=aladdin)用于存储[局部变量表](http://blog.csdn.net/kevin_luan/article/details/22986081)、[操作数栈](http://denverj.iteye.com/blog/1218359)、[动态链接](http://jnn.iteye.com/blog/83105)、方法出口等信息。每个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机中入栈到进栈的过程。

如果线程请求的栈深度大于虚拟机所能允许的深度时将抛出*StackOverflowError异常(可以通过无限递归呈现此异常)，
如果虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

c）本地方法栈

本地方法栈与虚拟机栈作用相似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到得Native方法服务。

  - Sun HotSpot虚拟机将本地方法栈和虚拟机栈合二为一了。
  - 其所会产生与Java虚拟机栈一样异常种类

2）线程共享数据区

所谓线程共享数据区，是指在多线程环境下，该部分区域数据可以被所有线程所共享。主要有Java堆、方法区数据区。

a）堆

运行时数据区域，所有类实例和数组的内存均从此处分配。Java 虚拟机启动时创建。对象的堆内存由称为垃圾回收器 的自动内存管理系统回收。

堆由两部分组成:

  - 新生代（Young Generation），包括Survivor space 0、Survivor space 1、Eden space
  - 老生代（Old Generation），主要存放应用程序中生命周期长的存活对象。

b）方法区

方法区与java堆栈一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等等。虽然java规范里面把方法区描述为堆的一个逻辑部分，但是其实它是一个非堆，其目的就是为了和java堆区分开。

如果方法区无法满足内存分配需求时候就会抛出OutOfMemoryError异常。

**说明：**

在HotSpot虚拟机中，很多人都把方法区成为永久代(Permanent Generation)，其实只有在hotspot才存在方法区。

永久代这块内存主要是被JVM存放类加载的信息和元数据信息，Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同，GC不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很多CLASS的话，就很可能出现PermGen space错误。

垃圾收集行为在这个区域比较少出现，这个区域的内存回收目标主要针对常量池的回收和对类型的卸载。

c）运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。其用于存放Java编译期生成的各种字面量和符号引用。

  - 运行期间也可能将新的常量放入常量池中，如String的intern()方法
  - 当常量池无法申请到足够内存时会抛出OutOfMemoryError异常

3）直接内存

直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

JDK1.4中出现了NIO，其引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中得DirectoryByteBuffer对象作为这块内存的引用进行操作。这样可以避免Java堆和Native堆之间的来回复制数据。

当机器直接内存去除JVM内存之后的内存不能满足直接内存大小要求其，将会抛出OutOfMemoryError异常。

# 垃圾回收过程

![jvm-heap.png](/assets/images/2014/jvm-heap.png)

JVM采用一种分代回收 (generational collection) 的策略，用较高的频率对年轻的对象(young generation)进行扫描和回收，这种叫做minor collection，而对老对象(old generation)的检查回收频率要低很多，称为major collection。这样就不需要每次GC都将内存中所有对象都检查一遍。

当一个URL被访问时，内存申请过程 如下：

- A. JVM会试图为相关Java对象在Eden中初始化一块内存区域
- B. 当Eden空间足够时，内存申请结束。否则到下一步
- C. JVM试图释放在Eden中所有不活跃的对象，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区
- D. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区
- E. 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集
- F. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”

对象衰老的过程：

young generation的内存，由一块Eden和两块Survivor Space(1.4文档中称为semi-space)构成。新创建的对象的内存都分配自eden。两块Survivor Space总有会一块是空闲的，用作copying collection的目标空间。

Minor collection的过程就是将eden和在用survivor space中的活对象copy到空闲survivor space中。所谓survivor，也就是大部分对象在伊甸园出生后，根本活不过一次GC。对象在young generation里经历了一定次数的minor collection后，年纪大了，就会被移到old generation中，称为tenuring。

剩余内存空间不足会触发GC，如eden空间不够了就要进行minor collection，old generation空间不够要进行major collection，permanent generation空间不足会引发full GC。


